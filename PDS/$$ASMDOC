*---------------------------------------------------------------------*
* ASM00001 KNUTH GENERATE PRIMES USING DECIMAL ARITHMETIC             *
*---------------------------------------------------------------------*

         18 JAN 1980 - CHARLES HOTTEL
         THIS PROGRAM CALULATES AND PRINTS ALL OF THE PRIME NUMBERS
         LESS THAN NMAX, BASED ON ALOGORITHM P IN DONALD KNUTH'S
         THE ART OF COMPUTER PROGRAMMING, FUNDAMENTAL ALGORITHMS,
         2ND EDITION. PAGES 143-144. USES PACKED DECIMAL ARITHMETIC.

*---------------------------------------------------------------------*
* ASM00002 KNUTH GENERATE PRINES USING BINARY ARITHMETIC              *
*---------------------------------------------------------------------*

         18 JAN 1980 - CHARLES HOTTEL
         THIS PROGRAM CALULATES AND PRINTS ALL OF THE PRIME NUMBERS
         LESS THAN NMAX, BASED ON ALOGORITHM P IN DONALD KNUTH'S
         THE ART OF COMPUTER PROGRAMMING, FUNDAMENTAL ALGORITHMS,
         2ND EDITION. PAGES 143-144. USES BINARY ARITHMETIC.

*---------------------------------------------------------------------*
* ASM00003 KNUTH COROUTINE                                            *
*---------------------------------------------------------------------*

         17 JUL 1980 - CHARLES HOTTEL
         KNUTH, FUNDAMENTAL ALGORITHMS, 2ND EDITION, PP 191-194
         COROUTINE EXAMPLE

  TRANSLATE ONE CODE INTO ANOTHER.  INPUT CODE TO BE TRANSLATED IS A
  SEQUENCE OF ALPHAMERIC CHARACTERS TERMINATED BY A PERIOD, E.G.,

  A2B5E3426FG0ZYW3210PQ89R.

  BLANK COLUMNS ARE TO BE IGNORED.  FROM LEFT TO RIGHT, IF THE NEXT
  CHARACTER IS A DIGIT, SAY N, IT INDICATES (N+1) REPETITIONS OF THE
  FOLLOWING CHARACTER, WHETHER THE FOLLOWING DIGIT IS A DIGIT OR NOT.
  A NONDIGIT SIMPLY DENOTES ITSELF.

  OUTPUT CONSISTS OF THE SEQUENCE INDICATED AND SEPARATED INTO GROUPS
  OF THREE CHARACTERS:

  ABB BEE EEE E44 446 66F GZY W22 220  0PQ 999 999 999 R.

  TWO COROUTINES AND A SUBROUTINE. SUBROUTINE 'NEXTCHAR' FINDS THE
  NONBLANK CHARACTER. COROUTINE 'IN' FINDS THE CHARACTERS OF THE
  INOUT CODE WITH THE PROPER REPLICATION. COROUTINE 'OUT' PUT THE CODE
  INTO THREE-DIGIT GROUPS.

*---------------------------------------------------------------------*
* ASM00004 KNUTH COROUTINE USING BALR R7,R8                           *
*---------------------------------------------------------------------*

         17 JUL 1980 - CHARLES HOTTEL
         KNUTH, FUNDAMENTAL ALGORITHMS, 2ND EDITION, PP 191-194
         COROUTINE EXAMPLE

  TRANSLATE ONE CODE INTO ANOTHER.  INPUT CODE TO BE TRANSLATED IS A
  SEQUENCE OF ALPHAMERIC CHARACTERS TERMINATED BY A PERIOD, E.G.,

  A2B5E3426FG0ZYW3210PQ89R.

  BLANK COLUMNS ARE TO BE IGNORED.  FROM LEFT TO RIGHT, IF THE NEXT
  CHARACTER IS A DIGIT, SAY N, IT INDICATES (N+1) REPETITIONS OF THE
  FOLLOWING CHARACTER, WHETHER THE FOLLOWING DIGIT IS A DIGIT OR NOT.
  A NONDIGIT SIMPLY DENOTES ITSELF.

  OUTPUT CONSISTS OF THE SEQUENCE INDICATED AND SEPARATED INTO GROUPS
  OF THREE CHARACTERS:

  ABB BEE EEE E44 446 66F GZY W22 220  0PQ 999 999 999 R.

  TWO COROUTINES AND A SUBROUTINE. SUBROUTINE 'NEXTCHAR' FINDS THE
  NONBLANK CHARACTER. COROUTINE 'IN' FINDS THE CHARACTERS OF THE
  INOUT CODE WITH THE PROPER REPLICATION. COROUTINE 'OUT' PUT THE CODE
  INTO THREE-DIGIT GROUPS.

  'IN' ------BALR R7,R8 -----> 'OUT'
  'IN' <-----BALR R8,R7 ------ 'OUT'

*---------------------------------------------------------------------*
* ASM00005 KNUTH COROUTINE USING BAL R7,0(R7)                         *
*---------------------------------------------------------------------*

         17 JUL 1980 - CHARLES HOTTEL
         KNUTH, FUNDAMENTAL ALGORITHMS, 2ND EDITION, PP 191-194
         COROUTINE EXAMPLE

  TRANSLATE ONE CODE INTO ANOTHER.  INPUT CODE TO BE TRANSLATED IS A
  SEQUENCE OF ALPHAMERIC CHARACTERS TERMINATED BY A PERIOD, E.G.,

  A2B5E3426FG0ZYW3210PQ89R.

  BLANK COLUMNS ARE TO BE IGNORED.  FROM LEFT TO RIGHT, IF THE NEXT
  CHARACTER IS A DIGIT, SAY N, IT INDICATES (N+1) REPETITIONS OF THE
  FOLLOWING CHARACTER, WHETHER THE FOLLOWING DIGIT IS A DIGIT OR NOT.
  A NONDIGIT SIMPLY DENOTES ITSELF.

  OUTPUT CONSISTS OF THE SEQUENCE INDICATED AND SEPARATED INTO GROUPS
  OF THREE CHARACTERS:

  ABB BEE EEE E44 446 66F GZY W22 220  0PQ 999 999 999 R.

  TWO COROUTINES AND A SUBROUTINE. SUBROUTINE 'NEXTCHAR' FINDS THE
  NONBLANK CHARACTER. COROUTINE 'IN' FINDS THE CHARACTERS OF THE
  INOUT CODE WITH THE PROPER REPLICATION. COROUTINE 'OUT' PUT THE CODE
  INTO THREE-DIGIT GROUPS.

  'IN' <---BAL R7,0(R7)---> 'OUT'

*---------------------------------------------------------------------*
* ASM00006 KNUTH COROUTINE USING BALR R7,R7                           *
*---------------------------------------------------------------------*

         17 JUL 1980 - CHARLES HOTTEL
         KNUTH, FUNDAMENTAL ALGORITHMS, 2ND EDITION, PP 191-194
         COROUTINE EXAMPLE

  TRANSLATE ONE CODE INTO ANOTHER.  INPUT CODE TO BE TRANSLATED IS A
  SEQUENCE OF ALPHAMERIC CHARACTERS TERMINATED BY A PERIOD, E.G.,

  A2B5E3426FG0ZYW3210PQ89R.

  BLANK COLUMNS ARE TO BE IGNORED.  FROM LEFT TO RIGHT, IF THE NEXT
  CHARACTER IS A DIGIT, SAY N, IT INDICATES (N+1) REPETITIONS OF THE
  FOLLOWING CHARACTER, WHETHER THE FOLLOWING DIGIT IS A DIGIT OR NOT.
  A NONDIGIT SIMPLY DENOTES ITSELF.

  OUTPUT CONSISTS OF THE SEQUENCE INDICATED AND SEPARATED INTO GROUPS
  OF THREE CHARACTERS:

  ABB BEE EEE E44 446 66F GZY W22 220  0PQ 999 999 999 R.

  TWO COROUTINES AND A SUBROUTINE. SUBROUTINE 'NEXTCHAR' FINDS THE
  NONBLANK CHARACTER. COROUTINE 'IN' FINDS THE CHARACTERS OF THE
  INOUT CODE WITH THE PROPER REPLICATION. COROUTINE 'OUT' PUT THE CODE
  INTO THREE-DIGIT GROUPS.

  'IN' <---BALR R7,R7---> 'OUT'

*---------------------------------------------------------------------*
* ASM00007 KNUTH ELEVATOR SIMULATION                                  *
*---------------------------------------------------------------------*

         18 MAY 1981 - CHARLES HOTTEL
         KNUTH, FUNDAMENTAL ALGORITHMS, 2ND EDITION, PP 279-293
         ELEVATOR SIMULATION

*---------------------------------------------------------------------*
* ASM00008 KNUTH ELEVATOR SIMULATION 2.2.5 EXERCISE 5                 *
*---------------------------------------------------------------------*

         18 MAY 1981 - CHARLES HOTTEL
         KNUTH, FUNDAMENTAL ALGORITHMS, 2ND EDITION, PP 279-293
         ELEVATOR SIMULATION

         SECTION 2.2.5 EXERCISE 5: MAN NUMBER 10, IN=2, OUT=4

*---------------------------------------------------------------------*
* ASM00009 KNUTH TOPOLOGICAL SORT                                     *
*---------------------------------------------------------------------*

         29 APR 1981 - CHARLES HOTTEL
         KNUTH, FUNDAMENTAL ALGORITHMS, 2ND EDITION, PP 250-265
         TOPOLOGICAL SORT (DOES NOT PRINT OUT LOOPS)

*---------------------------------------------------------------------*
* ASM00010 KNUTH TOPOLOGICAL SORT WITH LOOP DETECTION                 *
*---------------------------------------------------------------------*

         30 APR 1981 - CHARLES HOTTEL
         KNUTH, FUNDAMENTAL ALGORITHMS, 2ND EDITION, PP 250-265
         TOPOLOGICAL SORT (DOES PRINT OUT LOOPS)
         SEE EXERCISES 23 AND 24 PAGE 268.

*---------------------------------------------------------------------*
* ASM00011 KNUTH GENERATE 1000 SORT KEYS                              *
*---------------------------------------------------------------------*

         18 FEB 1983 - CHARLES HOTTEL
         KNUTH, SORTING AND SEARCHING,  2ND EDITION, PP 382

         K(1001) = ZERO
         K(N-1)  = (3141592621 * K(N) + 2113148651) MOD 10**10
                 = (         M * K(N) +          A) MOD 10**10

*---------------------------------------------------------------------*
* ASM00012 KNUTH DEFINE CONSTANT 1000 SORT KEYS                       *
*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
* ASM00013 COBSYS PROGRAM SHOWS SYSTEM INFORMATION INCLUDING CPU      *
*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
* ASM00014 KNUTH COMPARISON COUNT SORT 16 RECORDS                     *
*---------------------------------------------------------------------*

         18 FEB 1983 - CHARLES HOTTEL
         COMPARISON COUNTING SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 76-78.

         SORTS R(1), ... ,R(N) ON KEYS K(1), ... ,K(N) BY MAINTAINING
         AN AUXILLARY TABLE COUNT(1), ... ,COUNT(N) TO COUNT THE
         NUMBER OF KEYS LESS THAN A GIVEN KEY.  AT THE CONCLUSION
         COUNT(J) + 1 SPECIFIES THE FINAL POSITION OF R(J).

         NO MOVEMENT OF RECORDS, STABLE, NOT EFFICIENT WHEN LARGE
         NUMBER OF RECORDS.

*---------------------------------------------------------------------*
* ASM00015 KNUTH COMPARISON COUNT SORT 1000 RECORDS                   *
*---------------------------------------------------------------------*

         28 MAR 1983 - CHARLES HOTTEL
         COMPARISON COUNTING SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 76-78.

         SORTS R(1), ... ,R(N) ON KEYS K(1), ... ,K(N) BY MAINTAINING
         AN AUXILLARY TABLE COUNT(1), ... ,COUNT(N) TO COUNT THE
         NUMBER OF KEYS LESS THAN A GIVEN KEY.  AT THE CONCLUSION
         COUNT(J) + 1 SPECIFIES THE FINAL POSITION OF R(J).

         NO MOVEMENT OF RECORDS, STABLE, NOT EFFICIENT WHEN LARGE
         NUMBER OF RECORDS.

*---------------------------------------------------------------------*
* ASM00016 KNUTH DISTRIBUTION COUNT SORT 16 RECORDS                   *
*---------------------------------------------------------------------*

         30 MAR 1983 - CHARLES HOTTEL
         DISTRIBUTION COUNTING SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 78-79.

         ASSUMING ALL KEYS ARE INTEGERS IN RANGE U =< K(J) =< V.
         SORTS R(1), ... ,R(N) ON KEYS K(1), ... ,K(N) BY MAINTAINING
         AN AUXILLARY TABLE COUNT(U), ... ,COUNT(V) TO COUNT THE
         NUMBER OF KEYS LESS THAN A GIVEN KEY.

         FIRST ACCUMULATE COUNT(I) = NUMBER OF KEYS EQUAL TO I.
         CALCULATE COUNT(I) = NUMBER OF KEYS =< I.
         OUTPUT RECORDS TO S(1), ... ,S(N).

         EFFICIENT, STABLE, PRIMARILY APPLICABLE TO CASE OF MANY
         EQUAL KEYS IN SMALL KEY RANGE.

*---------------------------------------------------------------------*
* ASM00017 KNUTH DISTRIBUTION COUNT SORT 1000 RECORDS                 *
*---------------------------------------------------------------------*

         30 MAR 1983 - CHARLES HOTTEL
         DISTRIBUTION COUNTING SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 78-79.

         ASSUMING ALL KEYS ARE INTEGERS IN RANGE U =< K(J) =< V.
         SORTS R(1), ... ,R(N) ON KEYS K(1), ... ,K(N) BY MAINTAINING
         AN AUXILLARY TABLE COUNT(U), ... ,COUNT(V) TO COUNT THE
         NUMBER OF KEYS LESS THAN A GIVEN KEY.

         FIRST ACCUMULATE COUNT(I) = NUMBER OF KEYS EQUAL TO I.
         CALCULATE COUNT(I) = NUMBER OF KEYS =< I.
         OUTPUT RECORDS TO S(1), ... ,S(N).

         THIS PROGRAM SORTS THE TEN DIGITS ON THE LEFTMOST THREE
         DIGITS.

         EFFICIENT, STABLE, PRIMARILY APPLICABLE TO CASE OF MANY
         EQUAL KEYS IN SMALL KEY RANGE.

*---------------------------------------------------------------------*
* ASM00018 KNUTH STRAIGHT INSERTION SORT 16 RECORDS                   *
*---------------------------------------------------------------------*

         30 MAR 1983 - CHARLES HOTTEL
         STRAIGHT INSERTION SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 80-82.

         RECORDS R(1), ... ,R(N) REARRANGED IN PLACE.

         BEFORE EXAMINING RECORD R(J), WE ASSUME THAT THE PRECEEDING
         RECORDS R(1), ... ,R(J-1) HAVE ALREADY BEEN SORTED; THEN
         INSERT R(J) INTO ITS PROPER PLACE AMONG PREVIOUSLY SORTED
         RECORDS. CONVIENIENT TO COMBINE COMPARISON AND INTERLEAVING
         OPERATIONS.

         SHORT, STABLE, EFFICIENT FOR 25 RECORDS OR LESS.

*---------------------------------------------------------------------*
* ASM00019 KNUTH STRAIGHT INSERTION SORT 1000 RECORDS                 *
*---------------------------------------------------------------------*

         30 MAR 1983 - CHARLES HOTTEL
         STRAIGHT INSERTION SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 80-82.

         RECORDS R(1), ... ,R(N) REARRANGED IN PLACE.

         BEFORE EXAMINING RECORD R(J), WE ASSUME THAT THE PRECEEDING
         RECORDS R(1), ... ,R(J-1) HAVE ALREADY BEEN SORTED; THEN
         INSERT R(J) INTO ITS PROPER PLACE AMONG PREVIOUSLY SORTED
         RECORDS. CONVIENIENT TO COMBINE COMPARISON AND INTERLEAVING
         OPERATIONS.

         SHORT, STABLE, EFFICIENT FOR 25 RECORDS OR LESS.

*---------------------------------------------------------------------*
* ASM00020 KNUTH SHELL SORT 16 RECORDS                                *
*---------------------------------------------------------------------*

         04 APR 1983 - CHARLES HOTTEL
         SHELL SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 84-95.

         RECORDS R(1), ... ,R(N) REARRANGED IN PLACE.           ).

         SEQUENCE OF INCREMENTS H(T),H(T-1), ... ,H(1) USED TO CONTROL
         THE SORTING PROCESS WHERE H(1) = 1. PROPER CHOICE OF THESE
         INCREMENTS CAN SIGNIFICANTLY DECREASE THE SORTING TIME.
         THE BEST POSSIBLE SEQUENCE HAS NOT YET BEEN DETERMINED.

         DESIRABLE TO SORT WITH RELATIVELY PRIME INCREMENTS.
         UNWISE TO START WITH H(T) > N/3.
         SINCE THE INCREMENTS (3**K - 1) / 2 DO NOT TAKE
         SUBSTANTIALLY MORE MOVES, AND SINCE THEY REQUIRE ONLY
         ABOUT 5/8 AS MANY PASSES AS THE INCREMENTS OF OTHER FORMS,
         THE EVIDENCE INDICATES THAT IT IS REASONABLE TO CHOOSE THE
         INCREMENTS IN THE FOLLOWING WAY:

             LET H(1) = 1
             LET H(S+1) = 3*H(S) + 1
             STOP WITH H(T) WHEN H(T+2) GE N

         NOT STABLE, REASONABLY EFFICIENT FOR 1000 RECORDS OR LESS.

*---------------------------------------------------------------------*
* ASM00021 KNUTH SHELL SORT 1000 RECORDS                              *
*---------------------------------------------------------------------*

         04 APR 1983 - CHARLES HOTTEL
         SHELL SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 84-95.

         RECORDS R(1), ... ,R(N) REARRANGED IN PLACE.           ).

         SEQUENCE OF INCREMENTS H(T),H(T-1), ... ,H(1) USED TO CONTROL
         THE SORTING PROCESS WHERE H(1) = 1. PROPER CHOICE OF THESE
         INCREMENTS CAN SIGNIFICANTLY DECREASE THE SORTING TIME.
         THE BEST POSSIBLE SEQUENCE HAS NOT YET BEEN DETERMINED.

         DESIRABLE TO SORT WITH RELATIVELY PRIME INCREMENTS.
         UNWISE TO START WITH H(T) > N/3.
         SINCE THE INCREMENTS (3**K - 1) / 2 DO NOT TAKE
         SUBSTANTIALLY MORE MOVES, AND SINCE THEY REQUIRE ONLY
         ABOUT 5/8 AS MANY PASSES AS THE INCREMENTS OF OTHER FORMS,
         THE EVIDENCE INDICATES THAT IT IS REASONABLE TO CHOOSE THE
         INCREMENTS IN THE FOLLOWING WAY:

             LET H(1) = 1
             LET H(S+1) = 3*H(S) + 1
             STOP WITH H(T) WHEN H(T+2) GE N

         NOT STABLE, REASONABLY EFFICIENT FOR 1000 RECORDS OR LESS.

*---------------------------------------------------------------------*
* ASM00022 KNUTH LIST INSERTION SORT 16 RECORDS                       *
*---------------------------------------------------------------------*

         04 APR 1983 - CHARLES HOTTEL
         LIST INSERTION SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 96-97.

         RECORDS R(1), ... ,R(N) WITH LINK FIELDS L(1), ... ,L(N).
         ANOTHER LINK FIELD L(0) IN ARTIFICIAL RECORD R(0) AT
         BEGINNING OF FILE.  STARTING WITH RECORDS AT THE END
         OF THE FILE EACH RECORD IS INSERTED ON THE LIST IN ITS
         PROPER POSITION.  AT THE END THEY ARE LINKED TOGETHER IN
         ASCENDING ORDER.

         PARTICULARLY ADVANTAGES FOR VARIABLE LENGTH RECORDS OR
         RECORDS THAT ARE PART OF OTHER DATA STRUCTURES.

         STABLE, BEST FOR SMALLL N ONLY.

*---------------------------------------------------------------------*
* ASM00023 KNUTH LIST INSERTION SORT 1000 RECORDS                     *
*---------------------------------------------------------------------*

         04 APR 1983 - CHARLES HOTTEL
         LIST INSERTION SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 96-97.

         RECORDS R(1), ... ,R(N) WITH LINK FIELDS L(1), ... ,L(N).
         ANOTHER LINK FIELD L(0) IN ARTIFICIAL RECORD R(0) AT
         BEGINNING OF FILE.  STARTING WITH RECORDS AT THE END
         OF THE FILE EACH RECORD IS INSERTED ON THE LIST IN ITS
         PROPER POSITION.  AT THE END THEY ARE LINKED TOGETHER IN
         ASCENDING ORDER.

         PARTICULARLY ADVANTAGES FOR VARIABLE LENGTH RECORDS OR
         RECORDS THAT ARE PART OF OTHER DATA STRUCTURES.

         STABLE, BEST FOR SMALL N ONLY.

*---------------------------------------------------------------------*
* ASM00024 KNUTH OPTIMZED LIST INSERTION SORT 16 RECORDS              *
*---------------------------------------------------------------------*

         04 APR 1983 - CHARLES HOTTEL
         OPTIMIZED LIST INSERTION SORT SEE P104 EX 33

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 96-97.

         RECORDS R(1), ... ,R(N) WITH LINK FIELDS L(1), ... ,L(N).
         ANOTHER LINK FIELD L(0) IN ARTIFICIAL RECORD R(0) AT
         BEGINNING OF FILE.  STARTING WITH RECORDS AT THE END
         OF THE FILE EACH RECORD IS INSERTED ON THE LIST IN ITS
         PROPER POSITION.  AT THE END THEY ARE LINKED TOGETHER IN
         ASCENDING ORDER.

         PARTICULARLY ADVANTAGES FOR VARIABLE LENGTH RECORDS OR
         RECORDS THAT ARE PART OF OTHER DATA STRUCTURES.

         STABLE, BEST FOR SMALL N ONLY.

*---------------------------------------------------------------------*
* ASM00025 KNUTH OPTIMZED LIST INSERTION SORT 1000 RECORDS            *
*---------------------------------------------------------------------*

         04 APR 1983 - CHARLES HOTTEL
         OPTIMIZED LIST INSERTION SORT SEE P104 EX 33

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 96-97.

         RECORDS R(1), ... ,R(N) WITH LINK FIELDS L(1), ... ,L(N).
         ANOTHER LINK FIELD L(0) IN ARTIFICIAL RECORD R(0) AT
         BEGINNING OF FILE.  STARTING WITH RECORDS AT THE END
         OF THE FILE EACH RECORD IS INSERTED ON THE LIST IN ITS
         PROPER POSITION.  AT THE END THEY ARE LINKED TOGETHER IN
         ASCENDING ORDER.

         PARTICULARLY ADVANTAGES FOR VARIABLE LENGTH RECORDS OR
         RECORDS THAT ARE PART OF OTHER DATA STRUCTURES.

         STABLE, BEST FOR SMALLL N ONLY.

*---------------------------------------------------------------------*
* ASM00026 KNUTH MULTIPLE LIST INSERTION SORT 16 RECORDS              *
*---------------------------------------------------------------------*

         04 APR 1983 - CHARLES HOTTEL
         MULTIPLE LIST INSERTION SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 99-100.

         NEEDS KEYS TO BE EQUALLY DISTRIBUTED ACROSS RANGE

         NOT STABLE

*---------------------------------------------------------------------*
* ASM00027 KNUTH MULTIPLE LIST INSERTION SORT 1000 RECORDS            *
*---------------------------------------------------------------------*

         04 APR 1983 - CHARLES HOTTEL
         MULTIPLE LIST INSERTION SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 99-100.

         NEEDS KEYS TO BE EQUALLY DISTRIBUTED ACROSS RANGE

         NOT STABLE

*---------------------------------------------------------------------*
* ASM00028 KNUTH SHORT SLOW SORT 16 RECORDS                           *
*---------------------------------------------------------------------*

         04 APR 1983 - CHARLES HOTTEL
         A VERY SHORT AND VERY SLOW SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 102 EX. 5.2.1-3

*---------------------------------------------------------------------*
* ASM00029 KNUTH SHORT SLOW SORT 1000 RECORDS                         *
*---------------------------------------------------------------------*

         04 APR 1983 - CHARLES HOTTEL
         A VERY SHORT AND VERY SLOW SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 102 EX. 5.2.1 NUMBER 3

*---------------------------------------------------------------------*
* ASM00030 KNUTH BUBBLE SORT 16 RECORDS                               *
*---------------------------------------------------------------------*

         04 APR 1983 - CHARLES HOTTEL
         BUBBLE SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 106-110

         SLOW

*---------------------------------------------------------------------*
* ASM00031 KNUTH BUBBLE SORT 1000 RECORDS                             *
*---------------------------------------------------------------------*

         04 APR 1983 - CHARLES HOTTEL
         BUBBLE SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 106-110

         SLOW

*---------------------------------------------------------------------*
* ASM00032 KNUTH BATCHER'S MERGE EXCHANGE SORT 16 RECORDS             *
*---------------------------------------------------------------------*

         09 APR 1983 - CHARLES HOTTEL
         BATCHER'S MERGE EXCHANGE SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 111-114

         ESSENTIALLY SORT R1,R3,R5, ...
                      AND R2,R4,R6, ... INDEPENDENTLY
         AND THEN MERGE.

         NOT STABLE

*---------------------------------------------------------------------*
* ASM00033 KNUTH BATCHER'S MERGE EXCHANGE SORT 1000 RECORDS           *
*---------------------------------------------------------------------*

         09 APR 1983 - CHARLES HOTTEL
         BATCHER'S MERGE EXCHANGE SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 111-114

         ESSENTIALLY SORT R1,R3,R5, ...
                      AND R2,R4,R6, ... INDEPENDENTLY
         AND THEN MERGE.

         NOT STABLE

*---------------------------------------------------------------------*
* ASM00034 KNUTH QUICKSORT 16 RECORDS                                 *
*---------------------------------------------------------------------*

         13 APR 1983 - CHARLES HOTTEL
         QUICKSORT (PARTITION EXCHANGE)

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 114-123

         TAKE ONE RECORD AND MOVE IT TO ITS FINAL POSITION S. WHILE
         DETERMINING THIS FINAL POSITION REARRANGE THE RECORDS SO
         NONE WITH GREATER KEYS ARE TO THE LEFT OF POSITION S, AND
         NONE WITH SMALLER KEYS ARE TO THE RIGHT. THE FILE IS THUS
         PARTITIONED SO THAT THE ORIGINAL PROBLEM IS REDUCED TO TWO
         SIMPLER PROBLEMS, NAMELY TO SORT R(1), ... .R(S-1) AND
         (INDEPENDENTLY) R(S+1), ... ,R(N).

         M=9 SEEMS SLIGHTLY FASTER THAN M=8.

         VERY SLOW IF ORIGINAL FILE ALREADY IN ORDER.
         NOT STABLE

*---------------------------------------------------------------------*
* ASM00035 KNUTH QUICKSORT 1000 RECORDS                               *
*---------------------------------------------------------------------*

         13 APR 1983 - CHARLES HOTTEL
         QUICKSORT (PARTITION EXCHANGE)

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 114-123

         TAKE ONE RECORD AND MOVE IT TO ITS FINAL POSITION S. WHILE
         DETERMINING THIS FINAL POSITION REARRANGE THE RECORDS SO
         NONE WITH GREATER KEYS ARE TO THE LEFT OF POSITION S, AND
         NONE WITH SMALLER KEYS ARE TO THE RIGHT. THE FILE IS THUS
         PARTITIONED SO THAT THE ORIGINAL PROBLEM IS REDUCED TO TWO
         SIMPLER PROBLEMS, NAMELY TO SORT R(1), ... .R(S-1) AND
         (INDEPENDENTLY) R(S+1), ... ,R(N).

         M=9 SEEMS SLIGHTLY FASTER THAN M=8.

         VERY SLOW IF ORIGINAL FILE ALREADY IN ORDER.
         NOT STABLE

*---------------------------------------------------------------------*
* ASM00036 KNUTH QUICKSORT 16 RECORDS ALREADY IN ORDER                *
*---------------------------------------------------------------------*

         13 APR 1983 - CHARLES HOTTEL
         QUICKSORT (PARTITION EXCHANGE)

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 114-123

         TAKE ONE RECORD AND MOVE IT TO ITS FINAL POSITION S. WHILE
         DETERMINING THIS FINAL POSITION REARRANGE THE RECORDS SO
         NONE WITH GREATER KEYS ARE TO THE LEFT OF POSITION S, AND
         NONE WITH SMALLER KEYS ARE TO THE RIGHT. THE FILE IS THUS
         PARTITIONED SO THAT THE ORIGINAL PROBLEM IS REDUCED TO TWO
         SIMPLER PROBLEMS, NAMELY TO SORT R(1), ... .R(S-1) AND
         (INDEPENDENTLY) R(S+1), ... ,R(N).

         M=9 SEEMS SLIGHTLY FASTER THAN M=8.

         VERY SLOW IF ORIGINAL FILE ALREADY IN ORDER.
         NOT STABLE

         TESTING WORST CASE: ALL RECORDS ALREADY IN ORDER

*---------------------------------------------------------------------*
* ASM00037 KNUTH QUICKSORT 1000 RECORDS ALREADY IN ORDER              *
*---------------------------------------------------------------------*

         13 APR 1983 - CHARLES HOTTEL
         QUICKSORT (PARTITION EXCHANGE)

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 114-123

         TAKE ONE RECORD AND MOVE IT TO ITS FINAL POSITION S. WHILE
         DETERMINING THIS FINAL POSITION REARRANGE THE RECORDS SO
         NONE WITH GREATER KEYS ARE TO THE LEFT OF POSITION S, AND
         NONE WITH SMALLER KEYS ARE TO THE RIGHT. THE FILE IS THUS
         PARTITIONED SO THAT THE ORIGINAL PROBLEM IS REDUCED TO TWO
         SIMPLER PROBLEMS, NAMELY TO SORT R(1), ... .R(S-1) AND
         (INDEPENDENTLY) R(S+1), ... ,R(N).

         M=9 SEEMS SLIGHTLY FASTER THAN M=8.

         VERY SLOW IF ORIGINAL FILE ALREADY IN ORDER.
         NOT STABLE

         TESTING WORST CASE: ALL RECS ALREDY IN ORDER

*---------------------------------------------------------------------*
* ASM00038 KNUTH MEDIAN OF THREE QUICKSORT 16 RECORDS                 *
*---------------------------------------------------------------------*

         13 APR 1983 - CHARLES HOTTEL
         QUICKSORT (PARTITION EXCHANGE)

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 114-123

         TAKE ONE RECORD AND MOVE IT TO ITS FINAL POSITION S. WHILE
         DETERMINING THIS FINAL POSITION REARRANGE THE RECORDS SO
         NONE WITH GREATER KEYS ARE TO THE LEFT OF POSITION S, AND
         NONE WITH SMALLER KEYS ARE TO THE RIGHT. THE FILE IS THUS
         PARTITIONED SO THAT THE ORIGINAL PROBLEM IS REDUCED TO TWO
         SIMPLER PROBLEMS, NAMELY TO SORT R(1), ... .R(S-1) AND
         (INDEPENDENTLY) R(S+1), ... ,R(N).

         M=9 SEEMS SLIGHTLY FASTER THAN M=8.

         VERY SLOW IF ORIGINAL FILE ALREADY IN ORDER.
         NOT STABLE

*---------------------------------------------------------------------*
* ASM00039 KNUTH MEDIAN OF THREE QUICKSORT 1000 RECORDS               *
*---------------------------------------------------------------------*

         13 APR 1983 - CHARLES HOTTEL
         QUICKSORT (PARTITION EXCHANGE)

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 114-123

         TAKE ONE RECORD AND MOVE IT TO ITS FINAL POSITION S. WHILE
         DETERMINING THIS FINAL POSITION REARRANGE THE RECORDS SO
         NONE WITH GREATER KEYS ARE TO THE LEFT OF POSITION S, AND
         NONE WITH SMALLER KEYS ARE TO THE RIGHT. THE FILE IS THUS
         PARTITIONED SO THAT THE ORIGINAL PROBLEM IS REDUCED TO TWO
         SIMPLER PROBLEMS, NAMELY TO SORT R(1), ... .R(S-1) AND
         (INDEPENDENTLY) R(S+1), ... ,R(N).

         M=9 SEEMS SLIGHTLY FASTER THAN M=8.

         VERY SLOW IF ORIGINAL FILE ALREADY IN ORDER.
         NOT STABLE

*---------------------------------------------------------------------*
* ASM00040 KNUTH MEDIAN OF 3 QUICKSORT 16 RECORDS ALREADY IN ORDER    *
*---------------------------------------------------------------------*

         13 APR 1983 - CHARLES HOTTEL
         QUICKSORT (PARTITION EXCHANGE)

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 114-123

         TAKE ONE RECORD AND MOVE IT TO ITS FINAL POSITION S. WHILE
         DETERMINING THIS FINAL POSITION REARRANGE THE RECORDS SO
         NONE WITH GREATER KEYS ARE TO THE LEFT OF POSITION S, AND
         NONE WITH SMALLER KEYS ARE TO THE RIGHT. THE FILE IS THUS
         PARTITIONED SO THAT THE ORIGINAL PROBLEM IS REDUCED TO TWO
         SIMPLER PROBLEMS, NAMELY TO SORT R(1), ... .R(S-1) AND
         (INDEPENDENTLY) R(S+1), ... ,R(N).

         M=9 SEEMS SLIGHTLY FASTER THAN M=8.

         VERY SLOW IF ORIGINAL FILE ALREADY IN ORDER.
         NOT STABLE

         TESTING WORST CASE: ALL RECORDS ALREADY IN ORDER

*---------------------------------------------------------------------*
* ASM00041 KNUTH MEDIAN OF 3 QUICKSORT 1000 RECORDS ALREADY IN ORDER  *
*---------------------------------------------------------------------*

         13 APR 1983 - CHARLES HOTTEL
         QUICKSORT (PARTITION EXCHANGE)

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 114-123

         TAKE ONE RECORD AND MOVE IT TO ITS FINAL POSITION S. WHILE
         DETERMINING THIS FINAL POSITION REARRANGE THE RECORDS SO
         NONE WITH GREATER KEYS ARE TO THE LEFT OF POSITION S, AND
         NONE WITH SMALLER KEYS ARE TO THE RIGHT. THE FILE IS THUS
         PARTITIONED SO THAT THE ORIGINAL PROBLEM IS REDUCED TO TWO
         SIMPLER PROBLEMS, NAMELY TO SORT R(1), ... .R(S-1) AND
         (INDEPENDENTLY) R(S+1), ... ,R(N).

         M=9 SEEMS SLIGHTLY FASTER THAN M=8.

         VERY SLOW IF ORIGINAL FILE ALREADY IN ORDER.
         NOT STABLE

         TESTING WORST CASE: ALL RECORDS ALREADY IN ORDER

*---------------------------------------------------------------------*
* ASM00042 KNUTH RADIX EXCHANGE SORT 16 RECORDS                       *
*---------------------------------------------------------------------*

         22 APR 1983 - CHARLES HOTTEL
         RADIX EXCHANGE SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 123-129

         NOT STABLE

*---------------------------------------------------------------------*
* ASM00043 KNUTH RADIX EXCHANGE SORT 1000 RECORDS                     *
*---------------------------------------------------------------------*

         22 APR 1983 - CHARLES HOTTEL
         RADIX EXCHANGE SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 123-129

         NOT STABLE

*---------------------------------------------------------------------*
* ASM00044 KNUTH RADIX EXCHANGE SORT WITH BINARY KEY 1000 RECORDS     *
*---------------------------------------------------------------------*

         22 APR 1983 - CHARLES HOTTEL
         RADIX EXCHANGE SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 123-129

         NOT STABLE

*---------------------------------------------------------------------*
* ASM00045 KNUTH STRAIGHT SELECTION SORT 16 RECORDS                   *
*---------------------------------------------------------------------*

         22 APR 1983 - CHARLES HOTTEL
         STRAIGHT SELECTION SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 139-141

         NOT STABLE

*---------------------------------------------------------------------*
* ASM00046 KNUTH STRAIGHT SELECTION SORT 1000 RECORDS                 *
*---------------------------------------------------------------------*

         22 APR 1983 - CHARLES HOTTEL
         STRAIGHT SELECTION SORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 139-141

         NOT STABLE

*---------------------------------------------------------------------*
* ASM00047 KNUTH HEAPSORT 16 RECORDS                                  *
*---------------------------------------------------------------------*

         22 APR 1983 - CHARLES HOTTEL
         HEAPSORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 145-149

         NOT STABLE

*---------------------------------------------------------------------*
* ASM00048 KNUTH HEAPSORT 1000 RECORDS                                *
*---------------------------------------------------------------------*

         22 APR 1983 - CHARLES HOTTEL
         HEAPSORT

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 145-149

         NOT STABLE

*---------------------------------------------------------------------*
* ASM00049 KNUTH SUMMARY TABLE OF SORT TIMINGS                        *
*---------------------------------------------------------------------*

*---------------------------------------------------------------------*
* ASM00050 KNUTH SEQUENTIAL SEARCH 16 RECORDS                         *
*---------------------------------------------------------------------*

         17 OCT 1983 - CHARLES HOTTEL
         SEQUENTIAL SEARCH

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 393-394

*---------------------------------------------------------------------*
* ASM00051 KNUTH SEQUENTIAL SEARCH 1000 RECORDS                       *
*---------------------------------------------------------------------*

         17 OCT 1983 - CHARLES HOTTEL
         SEQUENTIAL SEARCH

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 393-394

*---------------------------------------------------------------------*
* ASM00052 KNUTH QUICK SEQUENTIAL SEARCH 16 RECORDS                   *
*---------------------------------------------------------------------*

         17 OCT 1983 - CHARLES HOTTEL
         QUICK SEQUENTIAL SEARCH

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGE 395

*---------------------------------------------------------------------*
* ASM00053 KNUTH QUICK SEQUENTIAL SEARCH 1000 RECORDS                 *
*---------------------------------------------------------------------*

         17 OCT 1983 - CHARLES HOTTEL
         QUICK SEQUENTIAL SEARCH

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGE 395

*---------------------------------------------------------------------*
* ASM00054 KNUTH QUICKER SEQUENTIAL SEARCH 16 RECORDS                 *
*---------------------------------------------------------------------*

         17 OCT 1983 - CHARLES HOTTEL
         QUICKER SEQUENTIAL SEARCH

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGE 395

*---------------------------------------------------------------------*
* ASM00055 KNUTH QUICKER SEQUENTIAL SEARCH 1000 RECORDS               *
*---------------------------------------------------------------------*

         17 OCT 1983 - CHARLES HOTTEL
         QUICKER SEQUENTIAL SEARCH

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGE 395

*---------------------------------------------------------------------*
* ASM00056 KNUTH BINARY SERACH 16 RECORDS                             *
*---------------------------------------------------------------------*

         19 OCT 1983 - CHARLES HOTTEL
         BINARY SEARCH

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 406 - 408.

*---------------------------------------------------------------------*
* ASM00057 KNUTH BINARY SERACH 1000 RECORDS                           *
*---------------------------------------------------------------------*

         19 OCT 1983 - CHARLES HOTTEL
         BINARY SEARCH

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 406 - 408.

*---------------------------------------------------------------------*
* ASM00058 UNIFORM BINARY SEARCH 16 RECORDS                           *
*---------------------------------------------------------------------*

         19 OCT 1983 - CHARLES HOTTEL
         UNIFORM BINARY SEARCH

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 411 - 412.

*---------------------------------------------------------------------*
* ASM00059 KNUTH UNIFORM BINARY SEARCH 1000 RECORDS                   *
*---------------------------------------------------------------------*

         19 OCT 1983 - CHARLES HOTTEL
         UNIFORM BINARY SEARCH

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 411 - 412.

*---------------------------------------------------------------------*
* ASM00060 KNUTH FIBONACCIAN SERACH 16 RECORDS                        *
*---------------------------------------------------------------------*

         19 OCT 1983 - CHARLES HOTTEL
         FIBONACCIAN SEARCH

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 414 - 416.

*---------------------------------------------------------------------*
* ASM00061 KNUTH FIBONACCIAN SEARCH 1000 RECORDS                      *
*---------------------------------------------------------------------*

         19 OCT 1983 - CHARLES HOTTEL
         FIBONACCIAN SEARCH

         THE ART OF COMPUTER PROGRAMMING, SORTING AND SEARCHING,
         2ND EDITION. PAGES 414 - 416.

*---------------------------------------------------------------------*
* ASM00062 KNUTH SUMMARY TABLE OF SEARCH TIMINGS                      *
*---------------------------------------------------------------------*
